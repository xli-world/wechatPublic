前述设计模式系列文章已讲述了“创建型模式”、“结构型模式”，本文继续讲解其中的最后一类模式，“行为模式”。这一类模式仍然分两部分讲解，第一部分讲解“责任链模式”、“命令模式”、“中介者模式”和“观察者模式”，它们用于处理请求发送者和接收者之间的不同连接方式，第二部分讲解剩余的“迭代器模式”、“备忘录模式”、“状态模式”、“策略模式”、“模版方法模式”、“访问者模式”。

### 责任链模式

#### 现实中的例子

> 假设你在支付宝付款方式中设置了3种付款方式（A、B、C），每种付款方式都有不同的余额，其中A有100元，B有300元，C有1000元，付款偏好设置为A->B->C。如果支付系统使用的是责任链模式的付款方式，则当你尝试支付210元时，系统会先检测你的A账户中钱是否足够，如果足够的话，则使用它来付款，责任链结束；反之，则会继续检查B账户中的钱是否足够。依此类推，直到找到第一个能处理这个支付款项的账户为止。

#### 模式定义

> 在面向对象的设计中，责任链模式是由一个命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含定义它可以处理的命令对象类型的逻辑；其余的被传递给链中的下一个处理对象。

#### 待解决的问题/解决方案

与许多其他行为设计模式一样，**责任链**会将特定行为转换为被称作*处理者*的独立对象。模式建议将这些处理者连成一条链。链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。除了处理请求外，处理者还负责沿着链传递请求。请求会在链上移动，直至所有处理者都有机会对其进行处理。当然，处理者也可以决定不再沿着链传递请求，这可高效地取消所有后续处理步骤。

![处理者依次排列，组成一条链](../img/责任链模式示例.png)

还有一种稍微不同的方式 （也是更经典一种），那就是处理者接收到请求后自行决定是否能够对其进行处理。如果自己能够处理，处理者就不再继续传递请求。因此在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理。 

#### 模式优缺点

##### 优点

*  你可以控制请求处理的顺序。
*  *单一职责原则*。 你可对发起操作和执行操作的类进行解耦。
*  *开闭原则*。 你可以在不更改现有代码的情况下在程序中新增处理者。

##### 缺点

-  部分请求可能未被处理。

#### Golang实践

参考https://github.com/xwangli/wechatPublic/tree/main/code/golang/design_pattern/responsibilitychain

### 命令模式

#### 现实中的例子

> 当你走进一个餐厅吃饭，一名服务员会走近你，记下你点的食物，写在一张纸上。之后，服务员来到厨房，把订单贴在墙上。过了一段时间，厨师拿到订单，他根据订单来准备食物。厨师将做好的食物和订单一起放在托盘上。服务员看到托盘后对订单进行检查，确保所有食物都是你要的，然后将食物放到了你的桌上。
>
> 那张纸就是一个命令，它在厨师开始烹饪前一直位于队列中。命令中包含与烹饪这些食物相关的所有信息。厨师能够根据它进行烹饪，而无需跑来直接和你确认订单详情。

#### 模式定义

> 命令模式允许你将动作封装在对象中。其中，对象是用于封装执行操作或稍后触发事件所需的所有信息。此信息包括方法名称、拥有该方法的对象和方法参数的值。这种模式背后的关键思想是提供将客户端与接收器分离的方法。

#### 模式优缺点

##### 优点

-  *单一职责原则*。 你可以解耦触发和执行操作的类。
-  *开闭原则*。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。
-  你可以实现撤销和恢复功能。
-  你可以实现操作的延迟执行。
-  你可以将一组简单命令组合成一个复杂命令。

##### 缺点

-  代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。

#### Golang实践

参考https://github.com/xwangli/wechatPublic/tree/main/code/golang/design_pattern/command

### 中介者模式

#### 现实中的例子

> 当你通过手机与某人通话时，你和他们之间有一个网络提供商，你们的对话都是通过它来中转，而不是直接发送给对方。在这种情况下，网络提供商就是中介。

#### 模式定义

> 中介者模式添加了一个第三方对象（称为中介者）来控制两个对象（称为同事）之间的交互。它有助于减少相互通信的类之间的耦合。因为现在他们不需要了解彼此的实现。

#### 待解决的问题/解决方案

有时候我们会用到很多相似的组件，组件与组件之间相互关联，如果把业务逻辑或关联关系写在组件中，会导致组件很难复用。

中介者模式建议停止组件之间的直接交流并使其相互独立。这些组件必须调用特殊的中介者对象，通过中介者对象重定向调用行为，以间接的方式进行合作。最终，组件仅依赖于一个中介者类，无需与多个其他组件相耦合。

#### 模式优缺点

##### 优点

-  *单一职责原则*。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。
-  *开闭原则*。 你无需修改实际组件就能增加新的中介者。
-  你可以减轻应用中多个组件间的耦合情况。
-  你可以更方便地复用各个组件。

##### 缺点

-  一段时间后， 中介者可能会演化成为上帝对象。

#### Golang实践

参考https://github.com/xwangli/wechatPublic/tree/main/code/golang/design_pattern/mediator

### 观察者模式

#### 现实中的例子

> 求职者会订阅一些职位发布网站，只要有匹配的工作机会，他们就会收到邮件/短信通知。

#### 模式定义

> 观察者模式是一种软件设计模式，其中称为主体的对象维护了一个其依赖项列表（称为观察者），当它有任何状态变更时，都会自动通知那些观察者。

#### 待解决的问题/解决方案

拥有一些值得关注的状态的对象通常被称为*目标*，由于它要将自身的状态改变通知给其他对象，我们也将其称为*发布者* （pub­lish­er）。所有希望关注发布者状态变化的其他对象被称为*订阅者* （sub­scribers）。

观察者模式建议为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。那么，无论何时发生了重要的发布者事件，它都可以遍历订阅者并调用其对象的特定通知方法。

所有订阅者都必须实现同样的接口，发布者仅通过该接口与订阅者交互。接口中必须声明通知方法及其参数，这样发布者在发出通知时还能传递一些上下文数据。

如果应用中有多个不同类型的发布者，且希望订阅者可兼容所有发布者，那么可以进一步让所有订阅者遵循同样的接口。该接口仅需描述几个订阅方法即可。这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。

#### 模式优缺点

##### 优点

- *开闭原则*。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
-  你可以在运行时建立对象之间的联系。

##### 缺点

-  订阅者的通知顺序是随机的。

#### Golang实践

参考https://github.com/xwangli/wechatPublic/tree/main/code/golang/design_pattern/observer