1. 背景介绍
2. 设计模式主要是基于以下的面向对象设计原则
   - 对接口编程而不是对实现编程。
   - 优先使用对象组合而不是继承。
3. 设计模式不是银弹

3. 参考文献
   1. https://draveness.me/holy-grail-design-pattern/





## 设计模式

设计模式是软件工程中比较常见，面试时经常被问到，听起来也比较高端的词汇。我们在开发一些中大型项目或者看一些开源项目时，一般也会有意无意的用上或者看到设计模式的影子。

本文从“设计模式是什么”、“它是怎么发展成现在这样的”、“我们为什么要学习它”、“它有什么缺点”这几个角度来系统性地阐述设计模式的相关知识，并会分四篇文章来详细讲解23种常见的设计模式及其在Golang中的应用。

### 设计模式是什么？

**设计模式**是软件设计中**常见问题**的**通用可重复解决方案**。 它们就像能根据需求进行调整的预制蓝图， 可用于**解决代码中反复出现的设计问题**。设计模式并不是一段特定的代码， **而是关于如何解决特定问题的描述或模板，可以在许多不同的场景下使用**。

设计模式一般会遵循以下几个设计原则：

1. 单一职责原则（Single Responsibility Principle）：一个类只负责一项职责（只有一个发生变化的原因）；
2. 开闭原则（Open-Closed Principle）：对扩展开放，对修改封闭；
3. 里氏替换原则（Liskov Substitution Principle）：基类适用的，子类一定适用（子类可以扩展父类的功能，但不能改变父类原有的功能）；
4. 依赖倒置原则（Dependence Inversion Principle）：依赖抽象，不要依赖具体（面向接口编程）；
5. 迪米特原则（Law Of Demeter）：一个对象应该对其他对象尽可能少的了解（最少知道）；
6. 接口隔离原则（Interface Segregation Principle）：使用多个专门的接口，而不要使用一个单一的（大）接口（接口单一职责）；
7. 组合/聚合复用原则 (Composite/Aggregate Reuse Principle)：尽量使用组合/聚合，而不是继承。

### 设计模式的历史

正如前面所说，设计模式是软件设计中常见问题的通用可重复解决方案。 同样的解决方案在各种项目中得到了反复使用， 最终有人给它们起了名字， 并对其进行了详细描述。 这基本上就是设计模式被发现的历程了。

模式的概念最初是由克里斯托佛·亚历山大在其著作 《[建筑模式语言](https://refactoringguru.cn/pattern-language-book)》 中首次提出， 书中介绍了城市设计的 “语言”， 而此类 “语言” 的基本单元就是模式。 模式中可能会包含对“窗户应该在多高”、“一座建筑应该有多少层”以及“一片街区应该有多大面积的植被”等信息的描述。

埃里希·伽玛、 约翰·弗利赛德斯、 拉尔夫·约翰逊和理查德·赫尔姆这四位作者接受了模式的概念。 1994 年， 他们出版了 《[设计模式： 可复用面向对象软件的基础](https://refactoringguru.cn/gof-book)》 一书， 将设计模式的概念应用到程序开发领域中。 该书提供了 23 种设计模式来解决面向对象程序设计中的各种问题， 很快便成为了畅销书。 由于书名太长， 人们将其简称为 “四人组 （Gang of Four， GoF） 的书”。

此后， 人们又发现了几十种面向对象的模式。  “模式方法” 开始在其他程序开发领域中流行起来。 如今， 在面向对象设计领域之外， 人们也提出了许多其他领域的模式，例如微服务架构设计模式、分布式系统设计模式等。

### 我们为什么要学习设计模式

设计模式并不是程序开发的必备知识，不会设计模式也能开发出好的程序。然而，学习设计模式能让我们遇到某些问题时能更加游刃有余：

- 设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种**经过实践验证的解决方案**。 即使我们从未遇到过这些问题，了解模式仍然非常有用， 因为它能指导你如何使用面向对象的设计原则来解决各种问题。
- 设计模式定义了一种让我们和团队成员能够更高效沟通的通用语言。 我们只需说 “这里用单例模式优化就可以了”， 所有人都会理解这条建议背后的意义，无需过多解释。 

### 关于模式的争议

设计模式自诞生之初就饱受争议，有的人觉得它提供了很多通用场景的解决方案，让人少走很多弯路，而有的人觉得它一无是处，束缚了人的思想。这几年对设计模式的批评主要有以下几点：

1. **一种针对不完善编程语言的蹩脚解决方案。**通常当所选编程语言或技术缺少必要的抽象功能时，人们才需要设计模式。在这种情况下，设计模式是一种可为语言提供更优功能的蹩脚解决方案。例如， 策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lambda） 函数来实现。
2. **低效的解决方案**。设计模式试图将已经广泛使用的方式系统化。 许多人会将这样的统一化认为是某种教条， 他们会 “完完全全” 地照搬这样的模式， 而不会根据项目的实际情况对其进行调整。
3. **不当使用。**这个问题常常会给初学模式的人们带来困扰： 在学习了某个模式后， 他们会在所有地方使用该模式， 即便是在较为简单的代码也能胜任的地方也是如此。正如Charlie Munger所言，“If all you have is a hammer, everything looks like a nail!”。
4. **增加沟通成本。**设计模式作为通用的术语确实可以增加不同工程师之间的沟通效率，但是降低沟通成本的前提是双方对同术语有着相同的并且正确的认识，如果双方的理解有差异，反而会制造更多的困惑。对于“单例模式”、“工厂模式”这些被广泛接受并理解的模式，沟通起来较为简单，也很难产生歧义；但对于“命令模式”、“解释器模式”这些较为复杂的模式，想要正确理解就已经非常困难，更不用说用来沟通了。
5. **与其他抽象没有显著区别。**设计模式与其他形式的抽象没有显著的区别，没有必要使用新的术语来描述编程领域的现有现象。如果设计模式算作模式的话，早它几年出现的MVC架构也能被称为模式。

### 设计模式分类

可以根据应用场景将设计模式分为以下三类：

1. **创建型模式。**创建型模式专注于如何实例化一个对象或一组相关对象。创建对象的方式可能会导致设计问题或增加设计的复杂性，创建型设计模式通过以某种方式控制对象的创建来解决此类问题。
2. **结构型模式。**结构型模式主要关注对象组合，即实体之间如何相互使用。它通过一些简单方法来标识实体之间的关系，简化设计。
3. **行为型模式。**行为型模式主要关注对象之间的职责分配。它们与结构模式的不同之处在于它们不仅指定了结构，还概述了它们之间消息传递/通信的模式。

### 设计模式详解

下面按类别依次介绍GoF书中提到的23种设计模式，每个模式从“待解决的问题”、“解决方案”、“适用场景”、“优缺点”、“Golang实践”这几个方面来介绍。

GoF书中涉及的设计模式主要是从面向对象语言中抽象出来的，然而正如Golang官方文档所言，Golang并不是一个真正意义上的面向对象的编程语言，因此有一些设计模式在Golang中的实现可能较为诡异，需要注意。

```
Is Go an object-oriented language?
Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes).

Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.
```

#### 创建型模式

##### 单例模式

单例模式用于保证一个类只有一个实例， 并提供了一个访问该实例的全局节点。

###### 现实中的例子

一个国家只会有一个总统/主席/政府，国家的大小事务需要由他/她/它来抉择。这里的总统/主席/政府即为一个单例。

###### 待解决的问题

单例模式主要解决以下两个问题：

1. **保证一个类只有一个实例。**
   1. 场景：有时候我们需要控制某些共享资源（如数据库、文件等）的访问权限，或者减少系统开销（避免创建多个实例，浪费系统资源）。
   2. 实现方式：如果你创建了一个对象，同时过一会儿后你决定再创建一个新对象，此时你会获得之前已创建的对象，而不是一个新对象。
2. **为该实例提供一个全局访问节点。**
   1. 场景：创建单例之后，需要允许在程序的任何地方访问到这个实例。这样才能方便对这个实例进行操作。

###### 解决方案

创建一个构建方法作为构造函数。该函数会实例化一个对象，并将其保存在一个变量中。此后所有对于该函数的调用都将返回这一缓存对象。

###### 适用场景

* **如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 **单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。

* **如果需要更加严格地控制全局变量， 可以使用单例模式。**单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

###### 优缺点

单例模式在解决上述两个问题时，引入了以下几个问题：

1. 违反了单一职责原则。 该模式同时解决了两个问题。
2. 可能掩盖了不良设计， 比如程序各组件之间相互了解过多等。

###### Golang实践

```go
package main

import (
    "fmt"
    "sync"
)

var lock sync.Mutex

type single struct {
}

var singleInstance *single

func getInstance() *single {
    if singleInstance == nil {
        // 先判断是否为nil，然后再上锁，之后再判断一次，减少被锁次数。
        lock.Lock()
        defer lock.Unlock()
        if singleInstance == nil {
            fmt.Println("创建单例中...")
            singleInstance = &single{}
        } else {
            fmt.Println("单例已创建")
        }
    } else {
        fmt.Println("单例已创建")
    }

    return singleInstance
}

func main() {
    for i := 0; i < 30; i++ {
        go getInstance()
    }

    // 用于控制程序退出
    fmt.Scanln()
}
```

##### 工厂模式

未完待续...

##### 抽象工厂模式

未完待续...

##### 生成器模式

未完待续...

##### 原型模式

未完待续...

#### 结构型模式

未完待续...

#### 行为型模式

未完待续...