今天延续之前“设计模式”系列未讲完的部分，讲一下设计模式中的结构性模式。为了便于大家理解比较，这一部分分两次讲解，第一次讲解其中比较容易混淆的四个模式“适配器模式”、“装饰器模式”、“外观模式”、“代理模式”。第二次讲解剩余的“桥接模式”、“组合模式”、“享元模式”。

为了便于大家比较，这次也换了一种描述/组织形式。

### 现实中的例子

#### 适配器

> 考虑到您的存储卡中有一些图片，您需要将它们传输到您的计算机。为了传输它们，您需要某种与您的计算机端口兼容的适配器，以便您可以将存储卡连接到您的计算机。在这种情况下，读卡器是一个适配器。
>
> 另一个例子是著名的电源适配器。三脚插头不能连接到两脚插座，它需要使用与两脚插座兼容的电源适配器。

#### 装饰器

> 想象一下，你经营一家提供多种服务的汽车服务店。现在你如何计算要收取的账单？你可以选择一项服务并动态地不断添加所提供服务的价格，直到你获得最终成本。这里每种类型的服务都是一个装饰器。

#### 外观模式

> 你怎么打开电脑？按下电源按钮--这就是你需要做的，因为你使用的是计算机在外部提供的简单界面，在内部它必须做很多事情才能实现。

#### 代理模式

> 你用过门禁卡进门吗？打开那扇门有多种选择，即可以使用门禁卡或按下绕过安全的按钮打开。门的主要功能是打开，但可以在其顶部添加了一个代理以添加一些功能。

### 待解决的问题/解决方案

大家看上面的例子，可能看的也比较模糊，有些例子说的场景好像有点类似。比方说，代理不是另外一种装饰器么？照着下面的定义去理解，可能更好理解一点：

| 模式   | 待解决的问题                                                 | 解决方案                                                     |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适配器 | 它用于解决两个类不兼容的问题                                 | 在适配器中包装一下原本不兼容的对象，以使其与另一个类兼容。   |
| 装饰器 | 需要修改一个对象的行为，但你又不想扩展它所属的类。因为，扩展类无法在运行时更改已有对象的行为，而且大部分编程语言中一个子类只能有一个父类。 | 装饰器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 装饰器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。 |
| 外观   | 假设你必须在代码中使用某个复杂的库或框架中的众多对象。正常情况下，你需要负责所有对象的初始化工作、管理其依赖关系并按正确的顺序执行方法等。这样的话，程序的业务逻辑将与第三方类的实现细节紧密耦合，使得理解和维护代码的工作很难进行。 | 外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。 |
| 代理   | 有时候我们需要控制对某个对象的访问（因为资源较大之类的原因...） | 代理模式新建一个与原服务对象接口相同的代理类，原始client通过代理来进行相应的处理逻辑。 代理类接收到client请求后会创建实际的服务对象， 并将所有工作委派给它。 |

### 模式的缺点

| 模式   | 缺点                                                         |
| ------ | ------------------------------------------------------------ |
| 适配器 | 代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。 |
| 装饰器 | 在装饰器栈中删除特定装饰器比较困难。</br>实现行为不受装饰栈顺序影响的装饰比较困难。 |
| 外观   | 外观可能成为与程序中所有类都耦合的上帝对象。                 |
| 代理   | 代码可能会变得复杂， 因为需要新建许多类。</br>服务响应可能会延迟。 |

### 与其他模式的关系

- 适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。
- 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。
- 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。
- 装饰和代理有着相似的结构，但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。
- 外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。

### Golang实践

